#!/usr/bin/env python
"""

"""
import os
import glob
import json
import numpy as np
import mdtraj as md
import matplotlib.pyplot as pp
from sklearn.mixture import log_multivariate_normal_density
from argparse import ArgumentParser
parser = ArgumentParser(__doc__)
parser.add_argument('--filename', required=True)
parser.add_argument('--n-states', type=int, required=True)
parser.add_argument('--n-per-state', type=int, default=3)
parser.add_argument('--lag-time', type=int, required=True)
parser.add_argument('--topology', required=True)

group_munge = parser.add_argument_group('Munging Options')
group_vector = group_munge.add_mutually_exclusive_group(required=True)
group_vector.add_argument('-d', '--distance-pairs', type=str,
                         help='''Vectorize the MD trajectories by extracting timeseries of the distance
                         between pairs of atoms in each frame. Supply a text file where each row contains
                         the space-separate indices of two atoms which form a pair to monitor''')
group_vector.add_argument('-a', '--atom-indices', type=str, help='''Superpose each MD conformation on the
                        coordinates in the topology file, and then use the distance from each atom in
                        the reference conformation to the corresponding atom in each MD conformation.''')
parser.add_argument('--dir')
parser.add_argument('--ext')

def iterobjects(fn):
    for line in open(fn, 'r'):
        if line.startswith('#'):
            print line
            continue
        obj = json.loads(line)
        # print obj['n_states'], obj['train_lag_time']
        yield obj


def main():
    args = parser.parse_args()
    obj = [o for o in iterobjects(args.filename) if o['n_states'] == args.n_states and o['train_lag_time'] == args.lag_time][0]

    means = np.array(obj['means'])
    vars = np.array(obj['vars'])
    transmat = np.array(obj['transmat'])

    top = md.load(args.topology)
    atom_indices = np.loadtxt(args.atom_indices, dtype=int)

    for fn in glob.glob(os.path.join(args.dir, '*.%s' % args.ext)):
        t = md.load(fn)
        t.superpose(top, atom_indices=atom_indices)
        diff2 = (t.xyz[:, atom_indices] - top.xyz[0, atom_indices])**2
        X = np.sqrt(np.sum(diff2, axis=2))
     
        logprob = log_multivariate_normal_density(X, means, vars, covariance_type='diag')
        assignments = np.argmax(logprob, axis=1)
        probs = np.max(logprob, axis=1)

        allframes = []
        for state in range(means.shape[0]):
            p = probs[assignments==state]
            indices = np.arange(len(assignments))[assignments==state][p.argsort()[-args.n_per_state:][::-1]]
            framelist = [md.load_frame(fn, i) for i in indices]
            allframes.extend(framelist)

        t = reduce(lambda a, b: a.join(b), allframes)
        print t
        t.superpose(t)
        t.save('structures.pdb')
            
    print atom_indices
    print obj['populations']
    transmat = np.array(obj['transmat'])
    print transmat.sum(axis=1)
    #print transmat
    #pp.matshow(transmat)
    pp.subplot(211)
    pp.title('means')
    pp.imshow(means, interpolation='none')
    pp.colorbar()
    pp.subplot(212)
    pp.title('1/vars')
    pp.imshow(1.0/vars, interpolation='none')
    pp.colorbar()

    pp.show()

if __name__ == '__main__':
    main()



